<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="referrer" content="no-referrer">
    <title>PR Dependency Graph Dashboard</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
        }

        .controls {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        .controls label {
            font-weight: 500;
        }

        .controls select, .controls input {
            padding: 5px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .stats {
            background: white;
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            font-size: 14px;
            color: #666;
        }

        .graph-container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            position: relative;
            overflow: hidden;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px;
            border-radius: 6px;
            pointer-events: none;
            font-size: 12px;
            max-width: 300px;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .tooltip h4 {
            margin: 0 0 8px 0;
            color: #fff;
        }

        .tooltip .pr-meta {
            margin: 4px 0;
            font-size: 11px;
            opacity: 0.8;
        }

        .node {
            cursor: pointer;
            stroke-width: 2px;
        }

        .node.open {
            stroke: #28a745;
        }

        .node.closed {
            stroke: #6c757d;
        }

        .node.draft {
            stroke: #ffc107;
        }

        .node.search-match {
            filter: brightness(1.3);
            stroke-width: 4px;
        }

        .link {
            stroke: #999;
            stroke-opacity: 0.6;
            stroke-width: 1.5px;
            fill: none;
        }

        .link.dependency {
            marker-end: url(#arrowhead);
        }

        .legend {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px;
            border-radius: 6px;
            font-size: 12px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 4px 0;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            border: 2px solid;
        }

        .loading {
            text-align: center;
            padding: 50px;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>PR Dependency Graph Dashboard</h1>
        <p>Interactive visualization of pull request dependencies in mathlib4</p>
        <p><a href="index.html">‚Üê Back to main dashboard</a> | Related: <a href="triage.html">Triage dashboard</a> | <a href="review_dashboard.html">Review queue</a></p>
    </div>

    <div class="controls">
        <div>
            <label for="searchFilter">Search:</label>
            <input type="text" id="searchFilter" placeholder="Search authors, titles, labels..." style="width: 300px;">
        </div>
        <div>
            <label for="showSingletons">
                <input type="checkbox" id="showSingletons"> Show singletons
            </label>
        </div>
        <button onclick="resetFilters()">Reset Filters</button>
        <button onclick="resetZoom()">Reset Zoom</button>
    </div>

    <div class="stats" id="stats">
        Loading dependency data...
    </div>

    <div class="graph-container">
        <div class="loading" id="loading">Loading PR dependency graph...</div>
        <svg id="graph"></svg>
        
        <div class="legend">
            <h4 style="margin: 0 0 8px 0;">Legend</h4>
            <div class="legend-item">
                <div class="legend-color" style="background: #28a745; border-color: #28a745;"></div>
                Unblocked (no dependencies)
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #007bff; border-color: #007bff;"></div>
                Blocked (has dependencies)
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ffc107; border-color: #ffc107;"></div>
                Draft/WIP
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #34ce57; border: 4px solid #1e7e34;"></div>
                Search Match (brighter)
            </div>
            <div class="legend-item">
                <div style="width: 12px; height: 2px; background: #999; margin-right: 8px; margin-left: 5px;"></div>
                Dependency
            </div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
        let graphData = null;
        let simulation = null;
        let svg = null;
        let g = null;
        let zoom = null;
        let currentFilter = { search: '', showSingletons: false };

        const width = window.innerWidth - 40;
        const height = window.innerHeight - 250;

        function initializeSVG() {
            zoom = d3.zoom()
                .scaleExtent([0.1, 10])
                .on("zoom", (event) => {
                    g.attr("transform", event.transform);
                });

            svg = d3.select("#graph")
                .attr("width", width)
                .attr("height", height)
                .call(zoom);

            svg.append("defs").append("marker")
                .attr("id", "arrowhead")
                .attr("viewBox", "0 -5 10 10")
                .attr("refX", 20)
                .attr("refY", 0)
                .attr("markerWidth", 6)
                .attr("markerHeight", 6)
                .attr("orient", "auto")
                .append("path")
                .attr("d", "M0,-5L10,0L0,5")
                .attr("class", "arrowhead")
                .style("fill", "#999");

            g = svg.append("g");
        }

        async function loadData() {
            try {
                const data = await d3.json("dependency_graph.json");
                graphData = data;
                
                updateStats(data.metadata);
                createVisualization(data);
                document.getElementById("loading").style.display = "none";
            } catch (error) {
                console.error("Error loading data:", error);
                document.getElementById("loading").innerHTML = 
                    "Error loading dependency data. Please ensure dependency_graph.json is available.";
            }
        }

        function updateStats(metadata) {
            const statsText = `
                Total PRs: ${metadata.total_prs} | 
                PRs with dependencies: ${metadata.prs_with_dependencies} | 
                PRs that are dependencies: ${metadata.prs_that_are_dependencies} | 
                Dependency links: ${metadata.dependency_links}
            `;
            document.getElementById("stats").innerHTML = statsText;
        }

        function isDraftLike(node) {
            return node.is_draft || node.labels.some(label => 
                label.toLowerCase().includes('wip')
            );
        }

        function getNodeColor(node) {
            if (isDraftLike(node)) {
                return "#ffc107"; // Yellow for draft/WIP
            }
            
            if (node.dependency_count > 0) {
                return "#007bff"; // Blue for blocked PRs (have dependencies)
            }
            
            return "#28a745"; // Green for unblocked PRs (no dependencies)
        }

        function getNodeStroke(node) {
            if (node.isSearchMatch) {
                // Return a darker version of the node color for search matches
                const baseColor = getNodeColor(node);
                if (baseColor === "#28a745") return "#1e7e34"; // Darker green
                if (baseColor === "#007bff") return "#0056b3"; // Darker blue  
                if (baseColor === "#ffc107") return "#e0a800"; // Darker yellow
            }
            return getNodeColor(node); // Same color as fill for normal nodes
        }

        function getNodeStrokeWidth(node) {
            return 2; // CSS will handle search match stroke width
        }

        function getNodeRadius(node) {
            const connections = node.dependency_count + node.dependent_count;
            return Math.max(5, Math.min(20, 5 + connections * 0.8));
        }

        function createVisualization(data) {
            // Clean slate approach: destroy existing simulation and clear SVG
            if (simulation) {
                simulation.stop();
                simulation = null;
            }
            
            svg.selectAll("*").remove();
            
            svg.append("defs").append("marker")
                .attr("id", "arrowhead")
                .attr("viewBox", "0 -5 10 10")
                .attr("refX", 20)
                .attr("refY", 0)
                .attr("markerWidth", 6)
                .attr("markerHeight", 6)
                .attr("orient", "auto")
                .append("path")
                .attr("d", "M0,-5L10,0L0,5")
                .attr("class", "arrowhead")
                .style("fill", "#999");

            g = svg.append("g");

            const filteredData = filterData(data);

            // Ensure clean link data with ID references
            const cleanLinks = filteredData.links.map(link => ({
                source: typeof link.source === 'object' ? link.source.id : link.source,
                target: typeof link.target === 'object' ? link.target.id : link.target,
                source_state: link.source_state,
                target_state: link.target_state
            }));

            simulation = d3.forceSimulation(filteredData.nodes)
                .force("link", d3.forceLink(cleanLinks).id(d => d.id).distance(50))
                .force("charge", d3.forceManyBody().strength(-200))
                .force("center", d3.forceCenter(width / 2, height / 2))
                .force("collision", d3.forceCollide().radius(d => getNodeRadius(d) + 2));

            const link = g.append("g")
                .attr("class", "links")
                .selectAll("path")
                .data(cleanLinks)
                .enter().append("path")
                .attr("class", "link dependency")
                .style("stroke", "#999")
                .style("stroke-width", 1.5);

            const node = g.append("g")
                .attr("class", "nodes")
                .selectAll("circle")
                .data(filteredData.nodes)
                .enter().append("circle")
                .attr("class", d => {
                    let classes = `node ${d.state}`;
                    if (d.is_draft) classes += ' draft';
                    if (d.isSearchMatch) classes += ' search-match';
                    return classes;
                })
                .attr("r", getNodeRadius)
                .style("fill", getNodeColor)
                .style("stroke", getNodeStroke)
                .style("stroke-width", getNodeStrokeWidth)
                .style("cursor", "pointer")
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended))
                .on("mouseover", showTooltip)
                .on("mouseout", hideTooltip)
                .on("click", (event, d) => {
                    window.open(d.url, '_blank');
                });

            simulation.on("tick", () => {
                link.attr("d", d => {
                    return `M${d.source.x},${d.source.y}L${d.target.x},${d.target.y}`;
                });

                node
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y);
            });

            simulation.alpha(1).restart();
            updateFilteredStats(data.metadata, filteredData);
        }

        // DFS to find all nodes in the same connected component
        function findConnectedComponent(nodeId, allNodes, allLinks) {
            const visited = new Set();
            const component = new Set();
            const stack = [nodeId];
            
            const adjacency = new Map();
            allNodes.forEach(node => adjacency.set(node.id, new Set()));
            
            allLinks.forEach(link => {
                const sourceId = link.source.id || link.source;
                const targetId = link.target.id || link.target;
                adjacency.get(sourceId)?.add(targetId);
                adjacency.get(targetId)?.add(sourceId);
            });
            
            while (stack.length > 0) {
                const currentId = stack.pop();
                if (visited.has(currentId)) continue;
                
                visited.add(currentId);
                component.add(currentId);
                
                const neighbors = adjacency.get(currentId) || new Set();
                neighbors.forEach(neighborId => {
                    if (!visited.has(neighborId)) {
                        stack.push(neighborId);
                    }
                });
            }
            
            return component;
        }

        function filterData(data) {
            let matchingNodes = new Set();
            let connectedComponentNodes = new Set();
            
            const hasSearchTerm = currentFilter.search && currentFilter.search.trim().length > 0;
            
            let availableNodes;
            if (currentFilter.showSingletons) {
                availableNodes = data.nodes;
            } else {
                // Filter out singletons - nodes with no dependencies or dependents
                availableNodes = data.nodes.filter(node => 
                    node.dependency_count > 0 || node.dependent_count > 0
                );
            }
            
            availableNodes.forEach(node => {
                let matches = true;
                
                let searchMatches = true;
                if (hasSearchTerm) {
                    const searchTerm = currentFilter.search.toLowerCase();
                    const searchableText = [
                        node.author.toLowerCase(),
                        node.title.toLowerCase(),
                        node.id.toString(),
                        ...node.labels.map(label => label.toLowerCase())
                    ].join(' ');
                    
                    searchMatches = searchableText.includes(searchTerm);
                }
                
                if (matches && searchMatches) {
                    matchingNodes.add(node.id);
                }
            });
            
            // Show connected components for search matches
            if (matchingNodes.size > 0 && hasSearchTerm) {
                matchingNodes.forEach(nodeId => {
                    const component = findConnectedComponent(nodeId, availableNodes, data.links);
                    component.forEach(id => connectedComponentNodes.add(id));
                });
            } else {
                availableNodes.forEach(node => connectedComponentNodes.add(node.id));
            }
            
            const filteredNodes = data.nodes.filter(node => 
                connectedComponentNodes.has(node.id)
            ).map(node => ({
                ...node,
                isSearchMatch: hasSearchTerm && matchingNodes.has(node.id)
            }));
            
            const filteredLinks = data.links.filter(link => {
                const sourceId = link.source.id || link.source;
                const targetId = link.target.id || link.target;
                return connectedComponentNodes.has(sourceId) && connectedComponentNodes.has(targetId);
            });

            return { nodes: filteredNodes, links: filteredLinks };
        }

        function updateFilteredStats(metadata, filteredData) {
            const baseStatsText = `
                Total PRs: ${metadata.total_prs} | 
                PRs with dependencies: ${metadata.prs_with_dependencies} | 
                PRs that are dependencies: ${metadata.prs_that_are_dependencies} | 
                Dependency links: ${metadata.dependency_links}
            `;
            
            const filteredStatsText = `
                Showing: ${filteredData.nodes.length} PRs, ${filteredData.links.length} dependencies
            `;
            
            document.getElementById("stats").innerHTML = baseStatsText + " | " + filteredStatsText;
        }

        function showTooltip(event, d) {
            const tooltip = document.getElementById("tooltip");
            const labels = d.labels.length > 0 ? d.labels.slice(0, 3).join(", ") + 
                          (d.labels.length > 3 ? "..." : "") : "None";
            
            const totalChanges = d.additions + d.deletions;
            const diffText = totalChanges > 0 ? 
                `<span style="color: #28a745;">+${d.additions}</span>/<span style="color: #dc3545;">-${d.deletions}</span> (${totalChanges} lines)` : 
                "No changes";
            
            function highlightMatches(text, searchTerm) {
                if (!searchTerm || searchTerm.trim().length === 0) {
                    return text;
                }
                
                const regex = new RegExp(`(${searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
                return text.replace(regex, '<span style="background-color: #ffff99; padding: 1px 2px; border-radius: 2px;">$1</span>');
            }
            
            const searchTerm = currentFilter.search ? currentFilter.search.trim() : '';
            
            const highlightedTitle = highlightMatches(d.title, searchTerm);
            const highlightedAuthor = highlightMatches(d.author, searchTerm);
            const highlightedLabels = highlightMatches(labels, searchTerm);
            const highlightedPrNumber = highlightMatches(d.id.toString(), searchTerm);
            
            const searchMatchText = d.isSearchMatch ? 
                `<div class="pr-meta" style="color: #ff0066; font-weight: bold;">üéØ Search Match</div>` : '';
            
            tooltip.style.background = "rgba(0, 0, 0, 0.9)";
            tooltip.style.border = "none";
            
            tooltip.innerHTML = `
                <h4>PR #${highlightedPrNumber}: ${highlightedTitle}</h4>
                <div class="pr-meta">Author: ${highlightedAuthor}</div>
                <div class="pr-meta">Status: ${isDraftLike(d) ? "Draft/WIP" : "Open"}</div>
                <div class="pr-meta">Diff: ${diffText}</div>
                <div class="pr-meta">Dependencies: ${d.dependency_count}</div>
                <div class="pr-meta">Dependents: ${d.dependent_count}</div>
                <div class="pr-meta">Labels: ${highlightedLabels}</div>
                ${searchMatchText}
                <div class="pr-meta">Click to open PR</div>
            `;
            
            tooltip.style.left = (event.pageX + 10) + "px";
            tooltip.style.top = (event.pageY - 10) + "px";
            tooltip.style.opacity = "1";
        }

        function hideTooltip() {
            document.getElementById("tooltip").style.opacity = "0";
        }

        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        function updateFilters() {
            currentFilter.search = document.getElementById("searchFilter").value;
            currentFilter.showSingletons = document.getElementById("showSingletons").checked;
            
            const url = new URL(window.location);
            if (currentFilter.search.trim()) {
                url.searchParams.set('search', currentFilter.search);
            } else {
                url.searchParams.delete('search');
            }
            
            if (currentFilter.showSingletons) {
                url.searchParams.set('singletons', 'true');
            } else {
                url.searchParams.delete('singletons');
            }
            
            window.history.replaceState({}, '', url);
            
            if (graphData) {
                createVisualization(graphData);
            }
        }

        function resetFilters() {
            document.getElementById("searchFilter").value = "";
            document.getElementById("showSingletons").checked = false;
            
            const url = new URL(window.location);
            url.searchParams.delete('search');
            url.searchParams.delete('singletons');
            window.history.replaceState({}, '', url);
            
            updateFilters();
        }

        function loadFiltersFromURL() {
            const url = new URL(window.location);
            const searchParam = url.searchParams.get('search');
            const singletonsParam = url.searchParams.get('singletons');
            
            if (searchParam) {
                document.getElementById("searchFilter").value = searchParam;
                currentFilter.search = searchParam;
            }
            
            if (singletonsParam === 'true') {
                document.getElementById("showSingletons").checked = true;
                currentFilter.showSingletons = true;
            }
        }

        function resetZoom() {
            svg.transition().duration(750).call(
                zoom.transform,
                d3.zoomIdentity
            );
        }

        document.getElementById("searchFilter").addEventListener("input", updateFilters);
        document.getElementById("showSingletons").addEventListener("change", updateFilters);

        loadFiltersFromURL();
        initializeSVG();
        loadData();

        window.addEventListener('resize', () => {
            const newWidth = window.innerWidth - 40;
            const newHeight = window.innerHeight - 250;
            
            svg.attr("width", newWidth).attr("height", newHeight);
            
            if (simulation) {
                simulation.force("center", d3.forceCenter(newWidth / 2, newHeight / 2));
                simulation.alpha(0.3).restart();
            }
        });
    </script>
</body>
</html> 